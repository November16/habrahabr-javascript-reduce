JavaScript в последние годы набрал нешуточную популярность, в связи с чем его подводные камни также стали явственно видны. Справедливости ради, стоит отметить, что любой язык в некоторой мере имеет как своё legacy, так и подводные камни.
Конкретно JavaScript обладает целым огородом камней. Подводным огородом.

На практике, подводные камни встречаются не так часто, напротив, хороший код склонен быть описанным в рамках здорового подмножества языка. Это также является и причиной, почему запомнить все заковырки языка достаточно сложно: они не являются необходимыми для каждодневной практики. Тем не менее, разнообразные граничные случаи использования языковых конструкций это отличная разминка для ума, а также стимул узнать язык немного лучше. Сегодняшний экземпляр попался мне на глаза в процессе прохождения <a href="http://javascript-puzzlers.herokuapp.com/">JavaScript Puzzlers</a>.

Меня заинтересовал <b>вопрос номер 3</b>:
Каков результат этого выражения (или нескольких)?

<source lang="javascript">
[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]
</source>
В качестве ответа авторами, на выбор, даются следующие варианты:
* ошибка
* <code>[9, 0]</code>
* <code>[9, NaN]</code>
* <code>[9, undefined]</code>

Попробуйте и вы, без запуска интерпретатора, пользуясь только своим умом ответить на этот вопрос.

Несмотря на то, что пример достаточно отстранённый, аппликация функций и частично определённых функций к коллекциям это распространённая практика для JS, и, при здравом использовании, она способна сделать код чище, как в плане исполнения — избавить его от лишних замыканий, так и в визуальном плане — меньше скобочного мусора (вопрос использования препроцессоров оставим для другой статьи).

А в этой статье вы найдёте:
* Разбор задачки.
* JavaScript <code>reduce</code> с чисто практической точки зрения.
* Несколько акробатических этюдов с <code>reduce</code> (<code>reduce</code> с академической точки зрения).
* Репозиторий с плюшками к статье.
* Несколько других <code>reduce</code>.
<habracut text="reduce, reduce, reduce" />
<h4>Разбор задачки</h4>
Чтож, для начала разберёмся с задачей в начале статьи. А вариантов здесь хватает.
<b>
<code>reduce</code></b> (здесь и далее имеется ввиду <code>Array.prototype.reduce</code>), вместе с другими функциями из прототипа <code>Array</code>: <code>filter</code>, <code>map</code>, <code>forEach</code>, <code>some</code>, <code>every</code>, является функцией высшего порядка, то есть она принимает на вход другую функцию (будем называть эту передаваемую функцию <code>f*</code>). Функция <code>f*</code> будет вызвана с некоторыми агрументами для каждого элемента коллекции.

Конкретно <code>reduce</code>, используется для генерации некоторого агрегирующего значения на основе коллекции. Она последовательно применяет <code>f*</code> к каждому элементу, передавая ей текущее значение переменной, в которой накапливается результат (аккумулятора) и текущий обрабатываемый элемент. Также, в <code>reduce</code> можно передать начальное значение аккумулятора. Причём, (!) поведение <code>reduce</code> <i>будет различаться в зависимости от того, передано это значение или нет</i>.

Функция <b><code>Math.pow</code></b> производит возведение в степень, то есть её поведение <i>различается в зависимости от переданной степени</i>: это может быть квадрат, куб, или квадратный корень или любая другая вещественная степень.

При этом остаются открытыми следующие вопросы:
* Как ведёт себя <code>reduce</code>, если вызвать её на пустом массиве?
* Как ведёт себя <code>Math.pow</code>, если недодать ей степень?

Для стандартных функций JS нет общей политики обработки ошибок. Некоторые функции могут действовать строго: бросать исключения, если что-то не так в переданных данных, некоторые будут возвращать всяческие пустые значения: <code>null</code>, <code>undefined</code>, <code>NaN</code>, а прочие будут работать пермиссивно: попытаются что-то сделать даже с не совсем корректными данными.

Как много вопросов затронул всего один пример.

А теперь правильный ответ: мы получим <code>TypeError</code>, в котором виновато второе подвыражение. Функция <code>reduce</code> на пустом массиве <b>И</b> без переданного начального значения бросает <code>TypeError</code>.

<h4>Почему так? Вчитываемся в спецификацию <code>reduce</code></h4>
Чтож, давайте почитаем что пишет <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce'>MDN o Array.prototype.reduce</a>. Выясняются следующие тонкости работы функции:
Если <code>initialValue</code> передано, то на первой итерации функция будет вызвана с этим значением и значением первого элемента массива. Если же, <code>initialValue</code> не передано, то функция будет вызвана со значениями первого и второго элементов массива. Отсюда также следует, что если начальное значение не передано, то <i>функция вызывается на один раз меньше</i>, иначе ровно столько раз, сколько элементов в массиве.

Можно представлять форму с <code>initialValue</code> вот так:

<source lang="javascript">
array.reduce(fn, initialValue) ⇔ [ initialValue ].concat(array).reduce(fn);
</source>
Вторым интересным аспектом является обработка пустого массива. Если массив пустой, и передано начальное значение, то оно является результатом работы функции, а результат <code>f*</code> <i>игнорируется</i>. Если же массив пуст, а начальное значение не передано, то выбрасывается <code>TypeError</code>.

<source lang="javascript">
[].reduce(fn, initialValue) ⇔ [ initialValue ].reduce(fn) ⇒ initialValue;
[].reduce(fn) ⇒ TypeError;
</source>
На самом деле поведение функции достаточно логично: она пытается вызвать <code>f*</code> со значениями из входных данных. Если начальное значение передано, то оно является элементом данных идущим перед первым элементом. Если не передано ничего (нет элементов и начального значения), то функция не имеет данных для генерации агрегата, и она выбрасывает исключение. Так или иначе, поведение немножко сложное и может стать подводным камнем. <code>reduce</code>, по сути, перегружается для одного агрумента и для двух, и перегруженные варианты имеют разное поведение на пустом массиве.

Теперь можно понять, почему задачка имеет такой результат, а именно, второе подвыражение бросает исключение: оно вызывается с пустым входным списком и без стартового значения. Но! Первое подвыражение всё-таки вычислилось. Предлагаю в качестве упражнения попытаться разобраться в этом вычислении. Можно пойти двумя путями:
* Джедайский: исполнить код в уме, зная о том как работают <code>reduce</code> и <code>Math.pow</code>.
* Ковбойский: вбить в REPL этот код и попытаться подвести рассуждения под результат.

Также, можно ознакомиться с моим примером, который должен помочь понять задачку:
<a href='https://github.com/StreetStrider/habrahabr-javascript-reduce/blob/master/tests/puzzler.js'>StreetStrider/habrahabr-javascript-reduce:tests/puzzler.js</a>. Он является jasmine-тестом.

<h4>Магия и шарм <code>reduce</code></h4>
<code>reduce</code> примечателен тем, что он может быть использован для того, чтобы описать все остальные функции высшего порядка объекта <code>Array</code>: <code>forEach</code>, <code>filter</code>, <code>map</code>, <code>some</code>, <code>every</code>.

Это станет понятным, если избавиться от мысли, что <code>reduce</code> обязан аккумулировать значение того же типа, что и значения в массиве. Действительно, логичным кажется мыслить, что если мы берём массив чисел и суммируем их, то получаем также число. Если мы берём массив строк и конкатенируем их, то также получаем строку. Это естественно, но <code>reduce</code> также способен возвращать массивы и объекты. Причём передача будет происходить из итерации в итерацию благодаря аккумулятору. Это позволяет строить на <code>reduce</code> функции любой сложности.

Для примера, давайте построим <code>map</code>:

<source lang="javascript">
function map$viaReduce (array, fn)
{
	return array.reduce(function (memo, item, index, array)
	{
		return memo.concat([ fn(item, index, array) ]);
	}, []);
};
</source>
Здесь через аккумулятор передаётся накапливающийся массив. Он будет того же размера, что и исходный, но со значениями, пропущенными через функцию-трасформатор <code>fn</code>. Также здесь не забыто, то <code>fn</code> принимает не только элемент, но индекс и массив последующими параметрами. Параметр функции <code>concat</code> обёрнут в массив, чтобы избежать «развёртки» значения, если <code>fn</code> вернёт массив. В качестве начального значения передан пустой массив.

Этот код есть в репозитории, а ещё для него есть тесты.

Тем, кто заинтересовался, предлагаю в качестве упражнения реализовать функции <code>filter</code>, и одну из кванторных: <code>some</code> либо <code>every</code>. Вы заметите, что везде используется возврат накапливаемого массива.

Ещё один нетривиальный пример, который приходит на ум, это реализация функции <code>uniq</code>. Как известно, JavaScript страдает от отсутствия в стандартной либе многих нужных вещей. В частности, нет функции, которая устраняет дубликаты в массиве, и разработчики используют разные кастомные реализации (лично я советую использовать <code>_.uniq</code> из LoDash/Underscore).

Эта реализация немного «<a href='http://habrahabr.ru/post/204430/'>хипстерская</a>», но как пример возможностей <code>reduce</code> сойдёт.
<source lang="javascript">
function uniq$viaReduce (array)
{
	return array.reduce(function (memo, item)
	{
		return (~ memo.indexOf(item) ? null : memo.push(item)), memo;
	}, []);
};
</source>
Здесь используется сайд-эффект внутри тернарного оператора, а именно, мы проталкиваем элемент в массив, если он не найден на текущем куске. Оператор тильда используется для сравнения с <code>-1</code>. Всё выражение завёрнуто в оператор запятую, который на каждом шаге (после всех действий) возвращает <code>memo</code>. Примечательно, что эта реализация также сохраняет порядок в массиве.

Код и тесты есть в репозитории.

Ладно, не «немного», этот код был сильно странный, меня оправдывает только наличие тестов и то, что это функция библиотечного типа, поведение которой не будет меняться. Желательно использовать другие реализации в своём коде, использование же как <code>reduce</code>, так и <code>indexOf</code> скажется отрицательным образом на производительности такого <code>uniq</code>, а обильное использование однострочников и тильд — на читаемости.

В качестве разминки, я рекомендую реализовать, например, функцию <code>zipObject</code> суть её в том, что она принимает на вход массив пар (массивов), где нулевой элемент это ключ, а первый — значение, и возвращает сконструированный <code>Object</code> с соответствующими ключами/значениями.

<h4>Подробнее о репозитории.</h4>
Репозиторий с примерами является npm-пакетом. Его можно поставить, используя адрес на гитхабе:
<source lang="bash">
npm install StreetStrider/habrahabr-javascript-reduce
</source>
В <code>src/</code> лежат примеры функций, в <code>tests/</code> — jasmine-тесты. Прогнать все тесты можно с помощью <code>npm test</code>.

В репозитории есть также ответ на вопрос о значении <code>Math.pow</code> при отсутствии степени (и другие граничные случаи).

<h4>Другие <code>reduce</code></h4>
* В JavaScript у <code>reduce</code> есть <s>злой брат-близнец</s> правосторонний аналог: <code>reduceRight</code>. Он нужен, чтобы агрегировать массивы справа-налево, без необходимости в дорогостоящем <code>reverse</code>.
* LoDash/Underscore есть <code>_.reduce</code>,<code> _.reduceRight</code>. Они обладают рядом дополнительных возможностей.
* В Python есть <code>reduce</code>. Да. Но он официально не рекомендуется к использованию. Вместо него предлагается использовать списковые выражения и конструкции <code>for-in</code>. Кода получается больше, но он становится намного более читаемым. Это соответствует Дао языка.
* В некоторых языках <code>reduce/reduceRight</code> называются <code>foldl/foldr</code>.

В SQL есть пять стандартных агрегирующих функций: <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>. Эти функции используются, чтобы свести результирующую выборку к одному кортежу. Аналогичные функции можно реализовать на JavaScript (тоже на <code>reduce</code>).

Кстати, четыре из пяти агрегирующих функций SQL (не считая <code>COUNT</code>) возвращают <code>NULL</code>, если выборка пустая (<code>COUNT</code> возвращает определённое значение: <code>0</code>). Это полностью аналогично JS-ному <code>TypeError</code> на пустом списке.

<source lang="bash">
postgres=# SELECT SUM(x) FROM (VALUES (1), (2), (3)) AS R(x);
 sum 
-----
   6
(1 row)
</source>
<source lang="bash">
postgres=# SELECT SUM(x) IS NULL AS sum FROM (VALUES (1), (2), (3)) AS R(x) WHERE FALSE;
 sum 
-----
 t
(1 row)
</source>
<h4>Итог</h4>
<code>reduce</code> это мощная функция, в терминах которой можно выразить другие функции высшего порядка, такие как <code>map</code> и <code>filter</code>. С этой мощью, к <code>reduce</code> приходит и сложность. <code>reduce</code> можно с успехом применять для различных суммирований и группировок, однако, стоит помнить, что любое агрегирование можно переписать используя обычный цикл, который может оказаться более легкочитаемым.

<h4>Ссылки<h4>
<ol>
  <li><a href="http://javascript-puzzlers.herokuapp.com/">JavaScript Puzzlers</a>.</li>
  <li><a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce'>MDN: Array.prototype.reduce()</a>.</li>
  <li><a href='https://github.com/StreetStrider/habrahabr-javascript-reduce'>github:StreetStrider/habrahabr-javascript-reduce</a>.</li>
  <li><a href='http://learn.javascript.ru/array-iteration'>JavaScript.ru: Массив: Перебирающие методы</a>.</li>
</ol>
<h4>Благодарности</h4>
Спасибо <hh user="subzey"/> за то, что натолкнул меня на мысль, что <code>reduce</code> может возвращать что угодно.
Спасибо всем, кто напишет мне в личные сообщения об ошибках и недочётах в статье, а также в репозитории.

Спасибо за внимание.
